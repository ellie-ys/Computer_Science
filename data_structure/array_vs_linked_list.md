# 주문 관리 시스템 문제 해결하는데 배열과 연결리스트의 차이점 비교

## 주문 생성, 제거, 조회의 기능

---

            |    배열  [big O]         | 연결리스트 [big O]

---

## addOrder | myList.append(n) [O(1)] | 끝에 하나 추가 [O(1)]

## removeOrder | myList.remove(n) [O(n)] | 따라가면서 찾은 후 삭제 [O(n)]

## getOrder | 몇 번째인지 반환 [O(n)] | 몇 번째인지 반환 [O(n)]

### 주문 횟수가 동일할 때를 기준으로

조회가 매우 많은 경우
배열 > 링크드리스트
배열이 조회에 유리하기 때문에 배열이 유리하다
반면, 추가 및 삭제는 불리하므로 조회가 많을 때보다 더 오랜시간 걸린다.

### 간단하게 구현해서 속도를 비교

## 배열,

조회 많을 경우 461~ 1136ms
주문조회 별로 없을 경우 843~7444ms

## 연결리스트,

조회 많을 경우 2000ms~ 5000ms
조회 별로 없을 경우 10000ms~ 100000ms

연결리스트 처리속도가 너무 느린 것을 알 수 있다.
연결리스트는 따라가면서 찾은 후 삭제하므로..

### 그럼 배열이랑 연결리스트의 시간복잡도는 비슷한데 왜 속도에서 차이가 날까?

배열의 요소들은 컴퓨터에서 물리적으로 가깝고
연결리스트는 산재되어있다. 별도 객체를 포인터로 연결하는 방식이라서
메모리상 인접한 위치 전체 요소를 순회하는 연산 또한 배열이 더 유리하다.

### 연결리스트의 특정 노드를 삭제하기 위해서는?

특정 노드에 접근하는 과정 필요하고, 이전 노드와 다음 노드가 무엇인지 알아야함
이 단점을 개선하기 위해, 연결리스트 내에 딕셔너리를 이용해 모든노드들의 정보 저장

딕셔너리 : 내부적으로 hash table이라는 자료구조로 동작
어떤 key에 대한 value를 O(1)의 시간복잡도로 접근 가능함.

## 주문관리시스템이 처리하는 주문이 양은 같더라도 주문 조회가 많을 때나 적을 때 유리한 자료구조가 각각 존재했다

주문조회는 배열이 유리
삽입삭제는 연결리스트가 유리

-> 알고리즘은 같더라도 데이터처리에따라 성능이 다름
